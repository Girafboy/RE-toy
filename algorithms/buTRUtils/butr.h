#ifndef _BOTTOMUP_FILE_H_#define _BOTTOMUP_FILE_H_#include "graph.h"#include "transitiveReduction.h"#include <iostream>#include <algorithm>namespace butr {    using namespace ::std;    stackN *stackV;    int *stackCRN, stackCRNTop;    int delEdgeNum;    int *rootTree;    EDGE *reverseTree;    int *reverseTreeEdge;    int *visitedNum;    int *vMax;    int *emOutG;    oneInterval topInterval;#ifdef BUTRINFO    int *diff;#endif    void initBU();    void sortNewGraph();    void estimationOutG();    void estimationOutG(const int vid);    void getReverseTree();    void buTree();    void delRdtEdge(const int vid);    void destroyBU();    void fun();    void getPoTree();    void initBU() {        stackV = stackTree;        stackCRN = new int[vertexNum];        rootTree = new int[vertexNum + 1];        reverseTree = graphT;        reverseTreeEdge = edgeT;        visitedNum = topOrderR;        vMax = new int[vertexNum];        emOutG = new int[vertexNum];#ifdef BUTRINFO        numOfReV = 0;        diff = new int[vertexNum];        for (int i = 0; i < vertexNum; ++i)        {            diff[i] = 0;        }#endif    }    void sortNewGraph() {        delEdgeNum = 0;        int vid, curV, start, end, ei;        for (int i = 0; i < vertexNum; ++i) {            inEdge[i].degree = 0;        }        for (int i = vertexNum; i > 0; --i) {            curV = topOrder[i];            if (2 == URN[curV]) {                //from graphTR                start = graphTR[curV].start;                end = start + graphTR[curV].degree;                ei = outEdge[curV].start;                while (start < end) {                    vid = edgeTR[start++];                    if (-1 != vid) {                        edge[ei++] = vid;                        edgeR[inEdge[vid].start + inEdge[vid].degree] = curV;                        inEdge[vid].degree++;                    } else {//					delEdgeNum++;                    }                }                outEdge[curV].degree = ei - outEdge[curV].start;            } else {                //from graphT                start = graphT[curV].start;                end = start + graphT[curV].degree;                ei = outEdge[curV].start;                while (start < end) {                    vid = edgeT[start++];                    if (-1 != vid) {                        edge[ei++] = vid;                        edgeR[inEdge[vid].start + inEdge[vid].degree] = curV;                        inEdge[vid].degree++;                    } else {//					delEdgeNum++;                    }                }                outEdge[curV].degree = ei - outEdge[curV].start;            }        }//	cout << " delEdgeNumFromTree " << delEdgeNum;    }    void estimationOutG() {        int *virOutDegree = virInDegree;        int tempRootNum = 0;        for (int i = 0; i < vertexNum; ++i) {            virOutDegree[i] = outEdge[i].degree;            vMax[i] = -1;            emOutG[i] = 0;            if (0 == outEdge[i].degree && (0 == (URN[i] & 3))) {                rootTree[++tempRootNum] = i;            }        }        rootTree[0] = tempRootNum;        int size = rootTree[0];        int head, tail;        int vid, curV, start, end;        for (int i = 1; i <= size; ++i) {            vid = rootTree[i];            head = tail = 0;            q[tail++] = vid;            while (head < tail) {                vid = q[head++];                estimationOutG(vid);                //update vid's parents                start = inEdge[vid].start;                end = start + inEdge[vid].degree;                while (start < end) {                    curV = edgeR[start++];                    if (0 == (URN[curV] & 3))//is not urn                    {                        if (vMax[curV] == -1 || emOutG[vMax[curV]] <= emOutG[vid]) {                            vMax[curV] = vid;                        }                        --virOutDegree[curV];                        if (0 == virOutDegree[curV]) {                            q[tail++] = curV;                        }                    }                }            }        }    }    void estimationOutG(const int vid) {        int nMax = emOutG[vMax[vid]];        if (4 == URN[vid])//CN        {            int outTX = interval[vid].end - interval[vid].start;            if (outTX >= nMax) {                emOutG[vid] = outTX;            } else {                emOutG[vid] = nMax;            }        } else {            int cNum = 0;            int cEmOut = 0;            int start, end, curV;            oneInterval preI, curI;            preI.start = 0;            preI.end = 0;            start = graphT[vid].start;            end = start + graphT[vid].degree;            while (start < end) {                curV = edgeT[start++];                if (-1 == curV) {                    continue;                }                curI.start = interval[curV].start;                curI.end = interval[curV].end;                if (curI.end > preI.end) {                    cNum++;                    //cEmOut += emOutG[curV];                    cEmOut += (curI.end - curI.start);                    preI.start = curI.start;                    preI.end = curI.end;                }            }            emOutG[vid] = cNum + max(nMax, cEmOut);        }    }    void getPoTree() {        for (int i = 0; i < vertexNum; ++i) {            reverseTree[i].start = inEdge[i].start;            reverseTree[i].degree = 0;        }        int vid, start, end;#ifdef BUTRINFO        numOfReV = 0;#endif        for (int i = 0; i < vertexNum; ++i) {            vid = vMax[i];            if (-1 != vid) {                reverseTreeEdge[reverseTree[vid].start + reverseTree[vid].degree] = i;                ++reverseTree[vid].degree;#ifdef BUTRINFO                numOfReV++;#endif            }        }// 	cout << " out the tree" << endl;        int size = rootTree[0];        int tempVisitedNum = 0;        int *st = q;#ifdef BUTRINFO        numOfReV += size;#endif        for (int i = 0; i < size; ++i) {            vid = rootTree[i + 1];            stackTop = 0;            st[stackTop++] = vid;            while (stackTop > 0) {                vid = st[--stackTop];                visitedNum[vid] = tempVisitedNum++;                start = reverseTree[vid].start;                end = start + reverseTree[vid].degree;                while (start < end) {                    st[stackTop++] = reverseTreeEdge[--end];                }            }        }    }    void getReverseTree() {        for (int i = 0; i < vertexNum; ++i) {            visited[i] = -1;            reverseTree[i].start = inEdge[i].start;            reverseTree[i].degree = 0;        }        int tempVisitedNum = 0;        int vid, curV;        int stackTop = -1;        int size = rootTree[0];        int tempChildNum;        int en = 0;        for (int i = 0; i < size; ++i) {            vid = rootTree[i + 1];#ifdef BUTRINFO            numOfReV++;#endif            visited[vid] = 1;            stackV[++stackTop].vertexID = vid;            stackV[stackTop].mark = -1;            visitedNum[vid] = tempVisitedNum++;            while (stackTop > -1) {                vid = stackV[stackTop].vertexID;                stackV[stackTop].mark++;                tempChildNum = stackV[stackTop].mark;                if (tempChildNum < inEdge[vid].degree) {                    curV = edgeR[inEdge[vid].start + tempChildNum];                    if (-1 == visited[curV] && 0 == (URN[curV] & 3))//curV is unVisited and is not URN                    {#ifdef BUTRINFO                        numOfReV++;#endif                        visited[curV] = 1;                        stackV[++stackTop].vertexID = curV;                        stackV[stackTop].mark = -1;                        visitedNum[curV] = tempVisitedNum++;                        reverseTreeEdge[reverseTree[vid].start + reverseTree[vid].degree] = curV;                        reverseTree[vid].degree++;                        ++en;                    }                } else {                    --stackTop;                }            }        }        cout << en << endl;    }    void buTree() {        int vid, curV;        stackCRNTop = -1;        int stackTop = -1;        for (int i = 0; i < vertexNum; ++i) {            indice[i] = -1;            visited[i] = vertexNum + 2;        }        int tempChild;        for (int i = rootTree[0]; i > 0; --i) {            vid = rootTree[i];            stackV[++stackTop].vertexID = vid;            stackV[stackTop].mark = reverseTree[vid].degree;            stackCRN[++stackCRNTop] = vid;            while (stackTop > -1) {                vid = stackV[stackTop].vertexID;                tempChild = --stackV[stackTop].mark;                if (tempChild >= 0) {                    curV = reverseTreeEdge[reverseTree[vid].start + tempChild];                    if (4 == URN[curV])//CRN                    {                        stackCRN[++stackCRNTop] = curV;                    } else {                        delRdtEdge(curV);                    }                    //if (1 != curV)                    {                        stackV[++stackTop].vertexID = curV;                        stackV[stackTop].mark = reverseTree[curV].degree;                    }                } else {                    --stackTop;                    if (4 == URN[vid]) {                        --stackCRNTop;                    }                }            }        }//	cout << " delEdgeNum " << delEdgeNum;    }    void delRdtEdge(const int vid) {        topInterval.start = interval[stackCRN[stackCRNTop]].start;        topInterval.end = interval[stackCRN[stackCRNTop]].end;        int start, end, v, curV;        int head, tail;        int vidNum = visitedNum[vid];        int pre = vMax[vid];        head = tail = 0;        start = outEdge[vid].start;        end = start + outEdge[vid].degree;        while (start < end) {#ifdef BUTRINFO            diff[vid]++;#endif            curV = edge[start++];            if (vidNum > visited[curV] ||                (topNum[curV] > topInterval.start && topNum[curV] <= topInterval.end)) {                //	delEdgeNum++;            } else {                visited[curV] = vidNum;                indice[curV] = vid;                if (pre != curV) {                    q[tail++] = curV;                }            }        }        while (head < tail) {            curV = q[head++];            start = outEdge[curV].start;            end = start + outEdge[curV].degree;            while (start < end) {#ifdef BUTRINFO                diff[vid]++;#endif                v = edge[start++];                if (visited[v] > vidNum                    && (topNum[v] < topInterval.start || topNum[v] > topInterval.end)) {                    visited[v] = vidNum;                    q[tail++] = v;                } else if (vid == indice[v]) {                    //	delEdgeNum++;                    indice[v] = -1;                }            }        }        start = outEdge[vid].start;        end = start + outEdge[vid].degree;        head = start;        while (start < end) {            curV = edge[start++];            if (vid == indice[curV]) {                edge[head++] = curV;                ++inEdge[curV].degree;            } else {                --inEdge[curV].degree;                //delEdgeNum++;            }        }        outEdge[vid].degree = head - outEdge[vid].start;    }    void fun() {        for (int i = 0; i < vertexNum; ++i) {            inEdge[i].degree = 0;        }        int start, end, vid;        for (int i = 0; i < vertexNum; ++i) {            start = outEdge[i].start;            end = start + outEdge[i].degree;            while (start < end) {                vid = edge[start++];                edgeR[inEdge[vid].start + inEdge[vid].degree] = i;                inEdge[vid].degree++;            }        }    }    void destroyBU() {        delete stackCRN;        delete rootTree;        delete vMax;        delete emOutG;#ifdef BUTRINFO        delete diff;#endif    }    void outReverseTree() {        int start, end, vid;        int size = rootTree[0];        cout << endl << "reverseTree" << endl;        for (int i = 0; i < size; ++i) {            vid = rootTree[i + 1];            cout << endl << vid;            start = reverseTree[vid].start;            end = start + reverseTree[vid].degree;            while (start < end) {                cout << " " << reverseTreeEdge[start++];            }        }    }#ifdef BUTRINFO    void testSize()    {        int maxE = 0;        double svn = vertexNum;        int number = vertexNum/1000;        if (vertexNum % 1000 > 0)            number++;        double *result = new double[number];        int ori, next;        for (int i = 0; i < number; ++i)        {            ori = 1000 * i;            next = min(ori + 1000, vertexNum);            svn = 0;            while (ori < next)            {                maxE = max(maxE, diff[ori]);                svn += diff[ori++];            }            result[i] = (double)svn/numOfReV;        }        for (int i = 1; i < number; ++i)        {            result[0] += result[i];        }        cout << " visitedEdge " << result[0];        cout << " maxE " << maxE;        cout << " numOfReV " << numOfReV;        delete result;    }#endif}#endif