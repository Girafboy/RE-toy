#ifndef _HOPLABEL_FILE_H_#define _HOPLABEL_FILE_H_#include "graph.h"//#include "priorityQueue.h"#include <string.h>#include "equalVertex.h"#include <vector>#include <algorithm>namespace butr {    using namespace ::std;    vector<vector<int> > outLabel, inLabel;//int *upRoot, *downRoot;    int *portalVertex;    int sn, tn, si, ti, sp, tp;    struct Root {        int ur;        int dr;    };    Root *R;    int *temQ;    void initHopLabel();    void initUpRoot();    void initDownRoot();    void portalVertexOrder();    void createP2HLabel();    void forwardIndex(const int &vid, const int &vidNum, int &vidLabelNumbers);    void reverseIndex(const int &vid, const int &vidNum, int &vidLabelNumbers);    inline bool interQuery(const int &sid, const int &tid);    void destroyHopLabel();    void outHopLabel();    void outRoot();    void hopSize();    void initHopLabel() {        outLabel = vector<vector<int> >(vertexNum);        inLabel = vector<vector<int> >(vertexNum);        portalVertex = new int[vertexNum + 1];        R = new Root[vertexNum];        temQ = new int[vertexNum];    }    void initUpRoot() {        int head, tail, curV;        int start, end, vid;        memset(indice, -1, sizeof(int) * vertexNum);        int size = zeroInDegree[0];        head = tail = 0;        for (int i = 1; i <= size; ++i) {            q[tail++] = zeroInDegree[i];            //	upRoot[zeroInDegree[i]] = zeroInDegree[i];            R[zeroInDegree[i]].ur = zeroInDegree[i];        }        while (head < tail) {            curV = q[head++];            start = outEdge[curV].start;            end = start + outEdge[curV].degree;            while (start < end) {                vid = edge[start++];                if (-1 == indice[vid]) {                    indice[vid] = 0;                    if (inEdge[vid].degree > 1) {                        //upRoot[vid] = vid;                        R[vid].ur = vid;                    } else {                        //	upRoot[vid] = upRoot[curV];                        R[vid].ur = R[curV].ur;                    }                    q[tail++] = vid;                }            }        }    }    void initDownRoot() {        memset(portalVertex, 0, sizeof(int) * vertexNum);        int porNum = 1;        int head, tail, curV;        int start, end, vid;        int size = zeroOutDegree[0];        head = tail = 0;        for (int i = 1; i <= size; ++i) {            q[tail++] = zeroOutDegree[i];            //	downRoot[zeroOutDegree[i]] = zeroOutDegree[i];            R[zeroOutDegree[i]].dr = zeroOutDegree[i];        }        while (head < tail) {            curV = q[head++];            if (outEdge[curV].degree > 1 || inEdge[curV].degree > 1) {                portalVertex[porNum++] = curV;            }            start = inEdge[curV].start;            end = start + inEdge[curV].degree;            while (start < end) {                vid = edgeR[start++];                if (1 != indice[vid]) {                    indice[vid] = 1;                    if (outEdge[vid].degree > 1) {                        //downRoot[vid] = vid;                        R[vid].dr = vid;                    } else {                        //downRoot[vid] = downRoot[curV];                        R[vid].dr = R[curV].dr;                    }                    q[tail++] = vid;                }            }        }        portalVertex[0] = porNum - 1;    }    void portalVertexOrder() {#ifdef QUERYINFO        cout << " portalVertex " << portalVertex[0];        int rootNum = 0;        for (int i = 0; i < vertexNum; ++i)        {            if (i == convertexEqualVertex[i])            {                if (i == R[i].ur || i == R[i].dr)                {                      rootNum++;                  }            }          }        cout << " rootNum " << rootNum;#endif        //return;        int size = portalVertex[0];        vector<pair<long long, int> > o(size);        vector<long long> val(size);        int vid, i;        for (i = 0; i < size; ++i) {            vid = portalVertex[i + 1];            val[i] = (long long) (outEdge[vid].degree + 1) * (long long) (inEdge[vid].degree + 1);            o[i] = make_pair(val[i], vid);        }        sort(o.begin(), o.end(), greater<pair<long long, int> >());        for (i = 0; i < size; ++i) {            portalVertex[i + 1] = o[i].second;        }    }    void createP2HLabel() {        memset(indice, -1, sizeof(int) * vertexNum);        memset(visited, -1, sizeof(int) * vertexNum);        int vid, nVisitedNodes = 0;        int size = portalVertex[0];        for (int i = 0; i < size; ++i) {            vid = portalVertex[i + 1];            visited[vid] = 1;            //	if (upRoot[vid] == downRoot[vid])            if (R[vid].dr == R[vid].ur) {                forwardIndex(vid, i, nVisitedNodes);                if (nVisitedNodes > 0) {                    outLabel[vid].push_back(i);                    nVisitedNodes = 0;                }                reverseIndex(vid, i, nVisitedNodes);                if (nVisitedNodes > 0) {                    inLabel[vid].push_back(i);                    nVisitedNodes = 0;                }            } else if (vid == R[vid].ur) {                reverseIndex(vid, i, nVisitedNodes);                if (nVisitedNodes > 0) {                    inLabel[vid].push_back(i);                    forwardIndex(vid, i, nVisitedNodes);                    nVisitedNodes = 0;                }            } else {                //down root                forwardIndex(vid, i, nVisitedNodes);                if (nVisitedNodes > 0) {                    outLabel[vid].push_back(i);                    reverseIndex(vid, i, nVisitedNodes);                    nVisitedNodes = 0;                }            }            //indice[vid] = 1;            indice[vid] = vid;        }    }    void forwardIndex(const int &vid, const int &vidNum, int &vidLabelNumbers) {        int head, tail, start, end, curV, v;        //start = outEdge[vid].start;        //end = start + outEdge[vid].degree;        head = tail = 0;        int temHead, temTail;        temHead = temTail = 0;        temQ[temTail++] = vid;        while (temHead < temTail) {            v = temQ[temHead++];            start = outEdge[v].start;            end = start + outEdge[v].degree;            while (start < end) {                curV = edge[start++];                if (1 != visited[curV]) {                    if (outEdge[curV].degree < 2 && inEdge[curV].degree < 2) {                        visited[curV] = 1;                        temQ[temTail++] = curV;                    } else {                        q[tail++] = curV;                    }                }            }        }        //while (start < end)        //{        //	curV = edge[start++];        //	if (1 != visited[curV])        //	{        //		q[tail++] = curV;        //		indice[curV] = vid;        //	}        //}        while (head < tail) {            v = q[head++];            if (1 == visited[v] || interQuery(vid, v)) {                continue;            }            if (v == R[v].ur) {                inLabel[v].push_back(vidNum);                vidLabelNumbers++;            }            start = outEdge[v].start;            end = start + outEdge[v].degree;            while (start < end) {                curV = edge[start++];                if (vid != indice[curV]) {                    q[tail++] = curV;                    indice[curV] = vid;                }            }        }    }    void reverseIndex(const int &vid, const int &vidNum, int &vidLabelNumbers) {        int head, tail, start, end, curV, v;        //start = inEdge[vid].start;        //end = start + inEdge[vid].degree;        head = tail = 0;        int temHead, temTail;        temHead = temTail = 0;        temQ[temTail++] = vid;        while (temHead < temTail) {            v = temQ[temHead++];            start = inEdge[v].start;            end = start + inEdge[v].degree;            while (start < end) {                curV = edgeR[start++];                if (1 != visited[curV]) {                    if (outEdge[curV].degree < 2 && inEdge[curV].degree < 2) {                        visited[curV] = 1;                        temQ[temTail++] = curV;                    } else {                        q[tail++] = curV;                    }                }            }        }        //while (start < end)        //{        //	curV = edgeR[start++];        //	if (1 != visited[curV])        //	{        //		q[tail++] = curV;        //		indice[curV] = vid;        //	}        //}        while (head < tail) {            v = q[head++];            if (1 == visited[v] || interQuery(v, vid)) {                continue;            }            if (v == R[v].dr) {                outLabel[v].push_back(vidNum);                vidLabelNumbers++;            }            start = inEdge[v].start;            end = start + inEdge[v].degree;            while (start < end) {                curV = edgeR[start++];                if (vid != indice[curV]) {                    q[tail++] = curV;                    indice[curV] = vid;                }            }        }    }    bool interQuery(const int &sid, const int &tid) {        sn = outLabel[sid].size();        tn = inLabel[tid].size();        si = 0;        ti = 0;        while (si < sn && ti < tn) {            sp = outLabel[sid][si];            tp = inLabel[tid][ti];            if (sp == tp) {                return true;            }            if (sp < tp) {                ++si;            } else {                ++ti;            }        }        return false;    }    void destroyHopLabel() {        delete[]portalVertex;        for (int i = 0; i < vertexNum; ++i) {            outLabel[i].clear();        }        for (int i = 0; i < vertexNum; ++i) {            inLabel[i].clear();        }        outLabel.clear();        inLabel.clear();        delete[]R;        delete temQ;    }    void outHopLabel() {        int size;        cout << endl << "hop out label" << endl;        for (int i = 0; i < vertexNum; ++i) {            cout << i << " :";            size = outLabel[i].size();            for (int j = 0; j < size; ++j) {                cout << " " << outLabel[i][j];            }            cout << endl;        }        cout << endl << "hop in label" << endl;        for (int i = 0; i < vertexNum; ++i) {            cout << i << " :";            size = inLabel[i].size();            for (int j = 0; j < size; ++j) {                cout << " " << inLabel[i][j];            }            cout << endl;        }        cout << endl;    }    void outRoot() {// 	cout << endl << "root" << endl;// 	for (int i = 0;i < vertexNum; ++i)// 	{// 		cout << i << "-" << upRoot[i] << "-" << downRoot[i] << endl;// 	}// 	cout << endl;    }    void hopSize() {        int size = 0;        for (int i = 0; i < vertexNum; ++i) {            size += outLabel[i].size();            size += inLabel[i].size();        }        cout << " hopSize " << size;    }    void outIndexSize() {        int count = 0;        int size = 0;        for (int i = 0; i < vertexNum; ++i) {            if (convertexEqualVertex[i] != i) {                count++;            }            size += outLabel[i].size();            size += inLabel[i].size();        }        double indexSize = ((vertexNum - count) * 7 + vertexNum + size) * 4.0 / (1024 * 1024);        cout << " indexSize:" << indexSize << " vertexNum:" << vertexNum << " count:" << count;        fstream fin;        fin.open("../result/data.txt", ios::out | ios::app);        fin << indexSize << " " << vertexNum << " " << count << " ";        fin.close();    }}#endif