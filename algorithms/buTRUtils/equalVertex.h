#ifndef _EQUALVERTEX_FILE_H_#define _EQUALVERTEX_FILE_H_#include "graph.h"#include "transitiveReduction.h"namespace butr {    int *convertexEqualVertex;    int *delVertex;    int *vertexset;    int *newset;    int *setnum;    void initEqVertex();    void equalNum();    void delEqualVertex();    void destroyEqVertex();    void outEqualVertex();    void sortGraph();//////////////////////////////////////////////////////////////////////////    void initEqVertex() {        convertexEqualVertex = new int[vertexNum];        delVertex = new int[vertexNum];        vertexset = new int[vertexNum];        newset = new int[vertexNum];        setnum = new int[vertexNum];    }    void equalNum() {        int start, end;        int setnum_head = 1;        int roll_tail = 0;        int vid;        for (int i = 0; i < vertexNum; i++) {            convertexEqualVertex[i] = i;            vertexset[i] = 0; //结点与集合对应关系            newset[i] = -1; //旧集合号与新集合号对应关系            setnum[i] = 0; //集合中元素个数            indice[i] = 0;//回滚位置，其实不用初始化            stackTree[i].vertexID = i; //可用的集合标号 栈        }        setnum[0] = vertexNum;        for (int i = 0; i < vertexNum; i++) {            start = outEdge[i].start;            end = outEdge[i].degree + start;            while (start < end) {                vid = edge[start++];                //	cout <<"set "<< setnum_head <<endl;                //	cout<<ID<<endl;                int old_id = vertexset[vid];                if (newset[old_id] == -1) {                    int ID = stackTree[setnum_head++].vertexID;                    newset[old_id] = ID;                    vertexset[vid] = ID;                    if (--setnum[old_id] == 0)                        stackTree[--setnum_head].vertexID = old_id;                    //	newset[ID] = ID;                    setnum[ID]++;                    indice[roll_tail++] = old_id;                } else {                    vertexset[vid] = newset[old_id];                    if (--setnum[old_id] == 0)                        stackTree[--setnum_head].vertexID = old_id;                    setnum[newset[old_id]]++;                    indice[roll_tail++] = old_id;                }            }            while (roll_tail > 0) {                int roll = indice[--roll_tail];                newset[roll] = -1;            }            start = inEdge[i].start;            end = inEdge[i].degree + start;            while (start < end) {                vid = edgeR[start++];                int old_id = vertexset[vid];                if (newset[old_id] == -1) {                    int ID = stackTree[setnum_head++].vertexID;                    newset[old_id] = ID;                    vertexset[vid] = ID;                    if (--setnum[old_id] == 0)                        stackTree[--setnum_head].vertexID = old_id;                    //	newset[ID] = ID;                    setnum[ID]++;                    indice[roll_tail++] = old_id;                } else {                    vertexset[vid] = newset[old_id];                    if (--setnum[old_id] == 0)                        stackTree[--setnum_head].vertexID = old_id;                    setnum[newset[old_id]]++;                    indice[roll_tail++] = old_id;                }            }            while (roll_tail > 0) {                int roll = indice[--roll_tail];                newset[roll] = -1;            }        }        int kk = 0;        for (int i = 0; i < vertexNum; i++) {            int setnum = vertexset[i];            if (newset[setnum] == -1) {                newset[setnum] = i;                convertexEqualVertex[i] = i;                delVertex[i] = -1;            } else {                kk++;                convertexEqualVertex[i] = newset[setnum];            }        }    }    void delEqualVertex() {        int start, end, curV, u;        for (int i = 0; i < vertexNum; ++i) {            inEdge[i].degree = 0;        }        for (int i = 0; i < vertexNum; ++i) {            if (i == convertexEqualVertex[i]) {                start = outEdge[i].start;                end = start + outEdge[i].degree;                u = start;                while (start < end) {                    curV = edge[start++];                    if (-1 == delVertex[curV])//curV is not deleted                    {                        edge[u++] = curV;                        edgeR[inEdge[curV].start + inEdge[curV].degree] = i;                        ++inEdge[curV].degree;                    }                }                outEdge[i].degree = u - outEdge[i].start;            } else {                outEdge[i].degree = 0;            }        }    }    void destroyEqVertex() {        delete[]convertexEqualVertex;        delete[]delVertex;        delete[]vertexset;        delete[]newset;        delete[]setnum;    }    void outEqualVertex() {        int count = 0;        cout << " equalVertex";        for (int i = 0; i < vertexNum; ++i) {            //	cout << i << "-" << convertexEqualVertex[i] << endl;            if (convertexEqualVertex[i] != i) {                count++;            }        }        cout << " " << vertexNum - count << " ";    }}#endif