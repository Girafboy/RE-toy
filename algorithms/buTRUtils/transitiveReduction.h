#ifndef _TRANSITIVEREDUCTION_FILE_H_#define _TRANSITIVEREDUCTION_FILE_H_#include "graph.h"#include "interval.h"#include <string.h>#include <algorithm>#include <iostream>namespace butr {    using namespace ::std;    struct stackN {        int vertexID;        int mark;    };    int *topLevel, *topLevelR;    int *topNum, *topNumR;    int *topOrder, *topOrderR;    EDGE *graphT, *graphTR;    int *edgeT, *edgeTR;    oneInterval *interval;    oneInterval *intervalR;    int *URN;    stackN *stackTree;    int *maxChild;    int *virInDegree;    void initPMTTR();    void constructTree();    void constructTreeR();    void initURN();    void isURN(const int &vid);    void checkURN(const int &vid);    bool isReducibleT(const int &vid);    bool isReducibleTR(const int &vid);    void virPMTTR();    void PMTTR();    void delPMTTR();    void destroyPMTTR();    void outInterval();    void remaiderGraphInformation();    void initPMTTR() {        topLevel = new int[vertexNum];        topLevelR = new int[vertexNum];        topNum = new int[vertexNum];        topNumR = new int[vertexNum];        topOrder = new int[vertexNum + 1];        topOrderR = new int[vertexNum + 1];        graphT = new EDGE[vertexNum];        graphTR = new EDGE[vertexNum];        edgeT = new int[edgeNum];        edgeTR = new int[edgeNum];        interval = new oneInterval[vertexNum];        intervalR = new oneInterval[vertexNum];        URN = new int[vertexNum];        stackTree = new stackN[vertexNum];        maxChild = new int[vertexNum];        virInDegree = new int[vertexNum];    }    void constructTree() {        for (int i = 0; i < vertexNum; ++i) {            virInDegree[i] = inEdge[i].degree;            topLevel[i] = -1;            graphT[i].degree = 0;            graphT[i].start = outEdge[i].start;        }        int parentLevel, curV, end, start, vid;        int topVertexNum = 1;        int topologyNum = 0;        int zeroInNum = zeroInDegree[0];        for (int i = 1; i <= zeroInNum; ++i) {            curV = zeroInDegree[i];            topLevel[curV] = 0;            stackTop = -1;            interval[curV].start = topologyNum;            topNum[curV] = topologyNum++;            topOrder[topVertexNum++] = curV;            start = outEdge[curV].start;            end = start + outEdge[curV].degree;            while (start < end) {                vid = edge[start++];                --virInDegree[vid];                topLevel[vid] = max(topLevel[vid], 1);                if (0 == virInDegree[vid]) {                    stackTree[++stackTop].vertexID = vid;                    stackTree[stackTop].mark = -1;                }            }            while (stackTop >= 0) {                if (0 == stackTree[stackTop].mark) {                    curV = stackTree[stackTop].vertexID;                    interval[curV].end = topologyNum - 1;                    --stackTop;                } else {                    curV = stackTree[stackTop].vertexID;                    stackTree[stackTop].mark = 0;                    parentLevel = topLevel[curV] + 1;                    interval[curV].start = topologyNum;                    topNum[curV] = topologyNum++;                    topOrder[topVertexNum++] = curV;                    //create graph                    start = inEdge[curV].start;                    end = start + inEdge[curV].degree;                    while (start < end) {                        vid = edgeR[start++];                        edgeT[graphT[vid].start + graphT[vid].degree] = curV;                        graphT[vid].degree++;                    }                    start = outEdge[curV].start;                    end = start + outEdge[curV].degree;                    while (start < end) {                        vid = edge[start++];                        --virInDegree[vid];                        topLevel[vid] = max(topLevel[vid], parentLevel);                        if (0 == virInDegree[vid]) {                            stackTree[++stackTop].vertexID = vid;                            stackTree[stackTop].mark = -1;                        }                    }                }            }            interval[zeroInDegree[i]].end = topologyNum - 1;        }        topOrder[0] = topVertexNum - 1;    }    void constructTreeR() {        for (int i = 0; i < vertexNum; ++i) {            virInDegree[i] = inEdge[i].degree;            topLevelR[i] = -1;            graphTR[i].degree = 0;            graphTR[i].start = outEdge[i].start;        }        int parentLevel, curV, end, start, vid;        int topVertexNum = 1;        int topologyNum = 0;        int zeroInNum = zeroInDegree[0];        for (int i = zeroInNum; i > 0; --i) {            curV = zeroInDegree[i];            topLevelR[curV] = 0;            stackTop = -1;            intervalR[curV].start = topologyNum;            topNumR[curV] = topologyNum++;            topOrderR[topVertexNum++] = curV;            start = outEdge[curV].start;            end = start + outEdge[curV].degree;            while (start < end) {                vid = edge[--end];                --virInDegree[vid];                topLevelR[vid] = max(topLevelR[vid], 1);                if (0 == virInDegree[vid]) {                    stackTree[++stackTop].vertexID = vid;                    stackTree[stackTop].mark = -1;                }            }            while (stackTop >= 0) {                if (0 == stackTree[stackTop].mark) {                    curV = stackTree[stackTop].vertexID;                    intervalR[curV].end = topologyNum - 1;                    --stackTop;                } else {                    curV = stackTree[stackTop].vertexID;                    stackTree[stackTop].mark = 0;                    parentLevel = topLevelR[curV] + 1;                    intervalR[curV].start = topologyNum;                    topNumR[curV] = topologyNum++;                    topOrderR[topVertexNum++] = curV;                    //create graph                    start = inEdge[curV].start;                    end = start + inEdge[curV].degree;                    while (start < end) {                        vid = edgeR[start++];                        edgeTR[graphTR[vid].start + graphTR[vid].degree] = curV;                        ++graphTR[vid].degree;                    }                    start = outEdge[curV].start;                    end = start + outEdge[curV].degree;                    while (start < end) {                        vid = edge[--end];                        --virInDegree[vid];                        topLevelR[vid] = max(topLevelR[vid], parentLevel);                        if (0 == virInDegree[vid]) {                            stackTree[++stackTop].vertexID = vid;                            stackTree[stackTop].mark = -1;                        }                    }                }            }            intervalR[zeroInDegree[i]].end = topologyNum - 1;        }        topOrderR[0] = topVertexNum - 1;    }    void initURN() {        memset(URN, 0, sizeof(int) * vertexNum);        int vid, size = topOrder[0], ii = 1;        //cout << endl;        while (ii <= size) {            vid = topOrder[ii++];            URN[vid] = 0;            int end = graphT[vid].start + graphT[vid].degree;            if (graphT[vid].degree > 0) {                maxChild[vid] = edgeT[end - 1];            } else {                maxChild[vid] = vid;            }            isURN(vid);            if (0 == URN[vid]) {                checkURN(vid);            }        }        int topElem;        while (stackTop >= 0) {            topElem = stackTree[stackTop].vertexID;            --stackTop;            if (stackTop >= 0) {                stackTree[stackTop].mark = max(stackTree[stackTop].mark, stackTree[stackTop + 1].mark);            }            if (stackTree[stackTop + 1].mark <= interval[topElem].end) {                URN[topElem] = 4;            }        }        //statistic the number of the URN    }    void isURN(const int &vid) {        bool parentFlag = true;        bool isT = isReducibleT(vid);        bool isTR = isReducibleTR(vid);        int curV, start, end;        //if (isReducibleT(vid))        //{        //	URN[vid] = 1;        //}        //end = graphT[vid].start + graphT[vid].degree;        //if (graphT[vid].degree > 0)        //{        //	maxChild[vid] = edgeT[end - 1];        //}        //else        //{        //	maxChild[vid] = vid;        //}        start = inEdge[vid].start;        end = start + inEdge[vid].degree;        while (start < end) {            curV = edgeR[start++];            if (0 == URN[curV] || 4 == URN[curV]) {                parentFlag = false;                URN[vid] = 0;                break;            }        }        if (parentFlag) {            if (isT) {                URN[vid] = 1;            }                //	else if (isReducibleTR(vid))            else if (isTR)                //if (0 == URN[vid] && isReducibleTR(vid))            {                URN[vid] = 2;            }        }    }    bool isReducibleT(const int &vid) {        int curV, curTopLevel;        int start, end;        start = graphT[vid].start;        end = start + graphT[vid].degree;        //if (graphT[vid].degree > 0)        //{        //	maxChild[vid] = edgeT[end - 1];        //}        //else        //{        //	maxChild[vid] = vid;        //}        //if (start == end || topNum[edgeT[end - 1]] <= interval[vid].end)        //{        //	flag1 = true;        //}        oneInterval preI, curI;        preI.start = 0;        preI.end = 0;        int lmin = vertexNum + 1;        int vidIntervalEnd = interval[vid].end;        while (start < end) {            curV = edgeT[start++];            curI.start = interval[curV].start;            curI.end = interval[curV].end;            curTopLevel = topLevel[curV];            if (curI.start < vidIntervalEnd) {                if (lmin > curTopLevel) {                    lmin = curTopLevel;                }                if (curI.end > preI.end) {                    preI.start = curI.start;                    preI.end = curI.end;                } else {                    //cout << vid << "->" << edgeT[start - 1] << endl;                    edgeT[start - 1] = -1;                }            } else {                if (curI.end > preI.end) {                    if (lmin < curTopLevel) {                        return false;                    } else {                        preI.start = curI.start;                        preI.end = curI.end;                        lmin = curTopLevel;                    }                } else {                    //cout << vid << "->" << edgeT[start - 1] << endl;                    edgeT[start - 1] = -1;                }            }        }        return true;    }    bool isReducibleTR(const int &vid) {        int curV, curTopLevel;        int start, end;        int vidIntervalEnd = intervalR[vid].end;        int lmin = vertexNum + 1;        oneInterval preI, curI;        preI.start = 0;        preI.end = 0;        start = graphTR[vid].start;        end = start + graphTR[vid].degree;        while (start < end) {            curV = edgeTR[start++];            curI.start = intervalR[curV].start;            curI.end = intervalR[curV].end;            curTopLevel = topLevelR[curV];            if (curI.start < vidIntervalEnd) {                if (lmin > curTopLevel) {                    lmin = curTopLevel;                }                if (curI.end > preI.end) {                    preI.start = curI.start;                    preI.end = curI.end;                } else {                    edgeTR[start - 1] = -1;                }            } else {                if (curI.end > preI.end) {                    if (lmin < curTopLevel) {                        return false;                    } else {                        preI.start = curI.start;                        preI.end = curI.end;                        lmin = curTopLevel;                    }                } else {                    edgeTR[start - 1] = -1;                }            }        }        return true;    }    void checkURN(const int &vid) {        int topElem;        while (stackTop >= 0) {            topElem = stackTree[stackTop].vertexID;            if (interval[topElem].end < interval[vid].start) {                --stackTop;                if (stackTop >= 0) {                    stackTree[stackTop].mark = max(stackTree[stackTop].mark, stackTree[stackTop + 1].mark);                }                if (stackTree[stackTop + 1].mark <= interval[topElem].end) {                    URN[topElem] = 4;                }            } else {                break;            }        }        stackTree[++stackTop].vertexID = vid;        stackTree[stackTop].mark = topNum[maxChild[vid]];    }    void destroyPMTTR() {        delete[]topLevel;        delete[]topLevelR;        delete[]topNum;        delete[]topNumR;        delete[]topOrder;        delete[]topOrderR;        delete[]graphT;        delete[]graphTR;        delete[]edgeT;        delete[]edgeTR;        delete[]interval;        delete[]intervalR;        delete[]URN;        delete[]stackTree;        delete[]maxChild;        delete[]virInDegree;    }    void outInterval() {        cout << endl;        for (int i = 0; i < vertexNum; ++i) {            cout << i << "-" << topNum[i] << "-" << topNumR[i] << "-";            cout << interval[i].start << "-" << intervalR[i].end << endl;        }        cout << endl;    }    void remaiderGraphInformation() {        int esize = 0;        for (int i = 0; i < vertexNum; ++i) {            esize += outEdge[i].degree;        }        cout << " re_Edge " << esize;    }}#endif