#ifndef _INTERVAL_FILE_H_#define _INTERVAL_FILE_H_#include "graph.h"namespace butr {    struct oneInterval {        int start;        int end;        int nextInterval;    };    oneInterval *dataInterval;    int *nullPos;    int firstNullPos;    int numOfInterval;    int maxInterval;    inline void initInterval();    int initInterval(const int &minInterval);    int initInterval(const int &startInterval, const int &endInterval);    void addNumberOfInterval();    void getPreInterval(int &pos, const int &val);    inline void getCurrentInterval(const int &pos, oneInterval &posInterval);    void intervalMerge(const int &pos, const int &mergePos);    inline int getNullPos();    inline void releaseInterval(const int &pos);    void destroyInterval();    void initInterval() {        maxInterval = vertexNum + 2;        firstNullPos = -1;        numOfInterval = vertexNum * SPACESIZE;        dataInterval = new oneInterval[numOfInterval];        nullPos = new int[numOfInterval];        for (int i = numOfInterval - 1; i >= 0; --i) {            nullPos[++firstNullPos] = i;            dataInterval[i].nextInterval = -1;        }    }    int initInterval(const int &minInterval) {        int curPos, temPos;        curPos = getNullPos();        temPos = getNullPos();        dataInterval[curPos].start = minInterval;        dataInterval[curPos].end = minInterval;        dataInterval[curPos].nextInterval = temPos;        dataInterval[temPos].start = maxInterval;        dataInterval[temPos].end = maxInterval;        dataInterval[temPos].nextInterval = -1;        return curPos;    }    int initInterval(const int &startInterval, const int &endInterval) {        int curPos, temPos;        curPos = getNullPos();        temPos = getNullPos();        dataInterval[curPos].start = startInterval;        dataInterval[curPos].end = endInterval;        dataInterval[curPos].nextInterval = temPos;        dataInterval[temPos].start = maxInterval;        dataInterval[temPos].end = maxInterval;        dataInterval[temPos].nextInterval = -1;        return curPos;    }    void addNumberOfInterval() {        int newNumOfInterval = numOfInterval * 2;        oneInterval *newDataInterval = new oneInterval[newNumOfInterval];        int *newNullPos = new int[newNumOfInterval];        //��������        for (int i = 0; i < numOfInterval; ++i) {            newDataInterval[i].start = dataInterval[i].start;            newDataInterval[i].end = dataInterval[i].end;            newDataInterval[i].nextInterval = dataInterval[i].nextInterval;        }        delete[]dataInterval;        dataInterval = newDataInterval;        delete[]nullPos;        nullPos = newNullPos;        //��¼��λ��        for (int i = newNumOfInterval - 1; i >= numOfInterval; --i) {            nullPos[++firstNullPos] = i;            newDataInterval[i].nextInterval = -1;        }        numOfInterval = newNumOfInterval;    }    void getPreInterval(int &pos, const int &val) {        int posNext = dataInterval[pos].nextInterval;        while (dataInterval[posNext].start <= val) {            pos = posNext;            posNext = dataInterval[pos].nextInterval;        }    }    void getCurrentInterval(const int &pos, oneInterval &posInterval) {        posInterval.start = dataInterval[pos].start;        posInterval.end = dataInterval[pos].end;    }    void intervalMerge(const int &pos, const int &mergePos) {        int curPos, curMergePos;        int temPos, newPos, releasePos;        curPos = pos;        curMergePos = mergePos;        while (dataInterval[curPos].start < maxInterval &&               dataInterval[curMergePos].start < maxInterval) {            getPreInterval(curPos, dataInterval[curMergePos].start);            if (dataInterval[curPos].end >= dataInterval[curMergePos].start - 1) {                dataInterval[curPos].end = max(dataInterval[curPos].end, dataInterval[curMergePos].end);                curMergePos = dataInterval[curMergePos].nextInterval;            } else {                temPos = dataInterval[curPos].nextInterval;                newPos = getNullPos();                dataInterval[newPos].start = dataInterval[curMergePos].start;                dataInterval[newPos].end = dataInterval[curMergePos].end;                dataInterval[newPos].nextInterval = temPos;                dataInterval[curPos].nextInterval = newPos;                curMergePos = dataInterval[curMergePos].nextInterval;                curPos = newPos;            }            temPos = dataInterval[curPos].nextInterval;            while (dataInterval[curPos].end >= dataInterval[temPos].start - 1) {                dataInterval[curPos].end = max(dataInterval[curPos].end, dataInterval[temPos].end);                releasePos = temPos;                temPos = dataInterval[temPos].nextInterval;                dataInterval[releasePos].nextInterval = -1;                nullPos[++firstNullPos] = releasePos;                dataInterval[curPos].nextInterval = temPos;            }        }    }    int getNullPos() {        int pos;        if (firstNullPos < 0) {            addNumberOfInterval();        }        pos = nullPos[firstNullPos];        if (dataInterval[pos].nextInterval > -1) {            nullPos[firstNullPos] = dataInterval[pos].nextInterval;        } else {            --firstNullPos;        }        return pos;    }    void releaseInterval(const int &pos) {        nullPos[++firstNullPos] = pos;    }    void destroyInterval() {        delete[]dataInterval;        delete[]nullPos;    }}#endif